# Рекурсия

Функция называется **рекурсивной**, если в процессе своего выполнения она вызывает сама себя. Суть рекурсии состоит в
разбиении одной большой задачи на более простые однотипные подзадачи, которые поступают на вход рекурсивному вызову.

Ветвь алгоритма, на которой задача сводится к более простой, и происходит рекурсивный вызов, называется **шагом
рекурсии**. 

Процесс повторяется до тех пор, пока очередную подзадачу нельзя разбить на более мелкие. Эта часть алгоритма
называется **базой рекурсии**. Другими словами, база рекурсии — это условие при котором функция прекращает вызывать саму
себя. База рекурсии позволяет выйти из цикла вызовов функции. 

Python и прочие языки программирования имеют ограничение
на количество вложенных вызовов функций или **глубину рекурсии**, по умолчанию для python это значение равно 1000. Ниже
приведена схема рекурсивного алгоритма.

![Рекурсия](../img/req_1.png)

Реализация рекурсивных вызовов функций неотрывно связана с такой структурой данных, как **стек вызовов** — адрес
возврата и локальные переменные функции записываются в стек, благодаря чему каждый следующий рекурсивный вызов этой
функции пользуется своим набором локальных переменных. Следует понимать, что при таком подходе на каждый рекурсивный
вызов требуется некоторое количество оперативной памяти, и при чрезмерно большой глубине рекурсии может наступить
переполнение стека вызовов. Поэтому иногда бывает целесообразно заменить рекурсию на итеративный подход.

Рассмотрим следующую задачу. Дан массив букв s. Напишите функцию, которая переворачивает строку задом наперед. Не
разрешается использовать дополнительную память, все преобразования должны производиться с исходным массивом.

Оригинал: [344. Reverse String](https://leetcode.com/problems/reverse-string/description/)

Реализация с использованием рекурсии

```python
from typing import List, Optional


def reverse_string(s: List[str], left: Optional[int] = 0) -> None:
    right = -(left + 1)
    if left > (len(s) // 2) - 1:
        return None

    reverse_string(s, left + 1)
    s[left], s[right] = s[right], s[left]
```

Итеративный подход с использованием двух указателей

```python
from typing import List


def reverse_string(s: List[str]) -> None:
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
```

Сравнение использования ЦПУ и памяти

![Сравнение использования ЦПУ и памяти](../img/req_2.png)

Как видим использование цикла сокращает потребление памяти, однако рекурсия иногда позволяет очень кратко и наглядно
решить поставленную задачу, например, рекурсию очень часто используют при обходе графов в глубину взамен явного
использования стека.