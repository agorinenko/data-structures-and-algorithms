# Массивы

![Массивы](../img/array_1.jpg)

Массив - коллекция элементов одного типа, располагающихся непрерывно в памяти. Динамический массив может изменять свой
размер в зависимости от количества элементов в нём. 

## Создание массива 

Массив может хранить N элементов. Это значение определяется при создании, также можно указать типы хранимых объектов. 
На основе количества элементов в памяти ищется и затем резервируется место в непрерывном адресном пространстве. 
Из-за этой особенности хранения проход по массиву происходит быстрее, чем например по связанному списку, однако 
изначальная инициализация памяти сложнее(особенно для больших массивов), ведь требуется подыскать свободное место без 
"разрывов". 

Динамический массив также изначально резервирует некий объем памяти. При полном ее заполнении происходит поиск нового 
адресного пространства уже большего размера и копирование в него старого массива. И так далее. Это проиллюстрировано 
на рисунке выше. Массив вместимостью в 5 элементов заполняется и затем выделяется память, очерченная красной рамкой.

Если при создании было установлено N, система заранее зарезервирует нужное количество ячеек памяти и в 
дальнейшем не будет накладных расходов по расширению адресного пространства и копированию туда старых элементов. Однако
важно понимать, что если выделить 10 000 ячеек и хранить данные только в 15 из них, остальные 9985 будут "простаивать".

При удалении элементов уменьшение размера массива никогда не происходит. В некоторых языках программирования для 
принудительного изменения размера можно использовать определенные инструменты.

## Длина и вместимость массива

Основные характеристики массива - длина и вместимость.

**Длина** - это количество элементов, находящихся в данный момент в массиве. 

**Вместимость** - это максимальное количество элементов, которое можно добавить в массив. Вместимость не может быть 
изменена после создания.

Сразу после создания длина равна 0, а вместимость зависит от того, динамический ли массив или с указанием N. После 
полного заполнения массива вместимость станет равна длине.

Временная сложность получения длины последовательности - **O(1)**

## Доступ к элементу

Элементы массива пронумерованы, причем нумерация начинается с 0 до N - 1. Позиция элемента называется его индексом. 
В большинстве языков программирования доступ по индексу производится с использованием квадратных скобок ``array[]``.
Если запросить доступ по индексу, где еще не был установлен элемент в Java вернется null если массив содержит объекты и
значения по умолчанию для примитивных типов. В С-подобных языках пустая ячейка может содержать полностью случайные 
величины.

Временная сложность получения элемента по индексу - **O(1)**

## Вставка элементов

Вставить элемент можно четырьмя путями - по индексу, в середину, в "голову" и в "хвост".

При вставке по индексу используются квадратные скобки ``array[3]=val``. Если в ячейке уже есть элемент, то он 
перезаписывается. Эта самый быстрый тип вставки, так как не требует расширения памяти или дополнительных операций с 
данными массива.

Вставка в "хвост" не требует дополнительных операций с данными массива, все что нам нужно сделать — это присвоить 
новому элементу индекс сразу после последнего элемента. Однако в случае полного заполнения массива 
происходит поиск новой большей области памяти и копирование туда старых данных. Операция затратная, но по статистике 
редкая поэтому не учитывается при расчете временной сложности.  

Вставка элемента в "голову" самая трудозатратная операция так как требует сдвига всех элементов массива на один 
индекс вправо, чтобы освободить место для нового элемента. При этом также может понадобиться расширение области памяти. 

Наконец вставка в середину подразумевает сдвиг всех правых элементов на одну позицию вправо и запись по индексу. По 
факту это общий случай вставки в "голову" с такой же временной сложностью.

Временная сложность операций:

Вставка элемента в середину - **O(n)**

Вставка элемента в "голову" - **O(n)**

Вставка элемента в "хвост" - **O(1)**

Присвоение значения по индексу - **O(1)**

## Удаление элементов

Удаление элемента из "головы" - **O(n)**

Удаление элемента из середины - **O(n)**

Удаление элемента из "хвоста" - **O(1)**

## Поиск по массиву

Проход по списку - **O(n)**
 
## Операции над исходным массивом